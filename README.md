## Inledning
I den här uppgiften fick vi utveckla ett trading system där användare kan skapa konton, lägga upp föremål (items) och byta med varandra genom trades. Jag valde att bygga ett system som känns tydligt och lätt att följa för mig själv delvis, där fokus ligger på att förstå hur olika delar hänger ihop och samarbetar.  

## Struktur och tekniker
Programmet har tre huvudklasser, **User**, **Item** och **Trade**. De samverkar genom **composition** vilket innebär att en klass innehåller objekt av en annan klass. Exempelvis har `User` en lista med `Item` objekt, och `Trade` innehåller både `User` och `Item`. Den här strukturen gör att varje klass får en tydlig roll och att programmet byggs upp av flera mindre delar som tillsammans skapar helheten.
Jag använder **listor (List<T>)** för att lagra användare, items och trades. Listor är dynamiska, vilket betyder att jag enkelt kan lägga till eller ta bort objekt utan att behöva bestämma någon fast storlek. Det passar ett system som hela tiden förändras. Jag valde bort **arrayer** eftersom de har en fast storlek och därmed hade krävt att jag skapade en ny array varje gång antalet objekt ändrades. Det hade gjort koden mindre flexibel.  
Jag hade även kunnat använda **Dictionary** för exepelvis att snabbt koppla email till användare, men valde att arbeta med listor och loopar för att tydligt visa logiken steg för steg. Det gör koden mer pedagogisk och lättare att förstå, särskilt för mig själv som fortfarande lär sig grunderna.

Jag använder även **loopar (while och foreach)** och **if-satser** eftersom de gör det tydligt hur programmet ska köra olika delar i rätt ordning. De hjälper mig att styra logiken på ett enkelt sätt och se till att programmet reagerar på det som faktiskt händer under körningen. 
Menyn är uppbyggd med **switch-case**, vilket gör det enkelt att navigera mellan de olika valen och lätt att utöka systemet med fler funktioner senare. Jag hade kunnat använda **enum** även för menyvalen, men jag valde att hålla det enkelt.
Jag använder också **booleans** (t.ex. `bool found = false;`) när jag vill veta om något hittats i en lista. I vissa fall använder jag istället `Count` för att kontrollera om en lista är tom, vilket gör koden lite mer kompakt.
För att visa statusen på varje trade använder jag en **enum** som heter `TradeStatus`. Den innehåller tre värden som är *Pending*, *Accepted* och *Denied*. Det gör att jag slipper hantera status som vanliga strängar, vilket minskar risken för felstavningar och ger en tydligare struktur. När jag sparar en trade till fil konverteras enumvärdet till text med `t.Status.ToString()`, och när programmet läser in filen igen översätts texten tillbaka till rätt enumvärde.

Jag har valt att inte använda **arv**, **polymorfism** eller **interfaces** i den här uppgiften, främst eftersom alla användare fungerar likadant. Men jag förstår hur de tre hänger ihop och hur de hade kunnat användas för att bygga ett mer avancerat system.
Om jag till exempel hade haft olika typer av användare hade jag kunnat skapa en basklass User som innehåller allt det gemensamma, och låta de andra ärva från den. Med arv hade varje användartyp kunnat bygga vidare på samma grund men lägga till egna funktioner.
Det här hade också öppnat upp för polymorfism, vilket betyder att olika klasser som delar samma basklass kan hanteras på samma sätt men bete sig olika i praktiken. Ett annat alternativ hade varit att använda interfaces, som istället för att ge arv fungerar som en mall. 

## Filhantering och lagring
All data sparas i separata **.txt-filer**. En för användare, en för items och en för trades. Efter feedback ändrade jag hur trades lagras, så att varje trade skrivs ut på flera rader. Den första raden visar vem som skickat och till vem, de följande raderna visar vilka items som ingår och vem som äger dem, och den sista raden visar statusen på traden. Jag använder `File.AppendAllText()` när jag lägger till nya trades, och `File.WriteAllLines()` när jag vill uppdatera hela filen (till exempel när en trade accepterats eller nekats). Det gör att jag kan spara och uppdatera data utan att gamla rader skrivs över i onödan.

## Tankar och förbättringar
Jag ser mitt program som enkelt men stabilt. Den gör exakt det som uppgiften kräver. Det känns som en bra grund att bygga vidare på, men jag ser samtidigt flera saker jag hade kunnat förbättra i efterhand. Om jag hade gjort om uppgiften hade jag troligtvis gått utanför min comfort zone och försökt mig på fler metoder. Jag valde det jag kände mig tryggast med i stunden, men uppgiften har gett mig en mycket bättre förståelse för hur allt hänger ihop. Jag har också lärt mig hur viktigt det är att planera strukturen i förväg och tänka långsiktigt på hur olika delar påverkar varandra. 
Sammanfattat kan man säga att jag är sådär nöjd med resultatet, men känner att jag nu har en stabil grund att bygga vidare på.
